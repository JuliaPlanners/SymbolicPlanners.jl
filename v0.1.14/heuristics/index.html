<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heuristics · SymbolicPlanners.jl</title><meta name="title" content="Heuristics · SymbolicPlanners.jl"/><meta property="og:title" content="Heuristics · SymbolicPlanners.jl"/><meta property="twitter:title" content="Heuristics · SymbolicPlanners.jl"/><meta name="description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="og:description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="twitter:description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="og:url" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/heuristics/"/><meta property="twitter:url" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/heuristics/"/><link rel="canonical" href="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/heuristics/"/><meta property="og:image" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/assets/preview.png"/><meta property="twitter:image" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SymbolicPlanners.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicPlanners.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../planners/">Planners</a></li><li class="is-active"><a class="tocitem" href>Heuristics</a><ul class="internal"><li><a class="tocitem" href="#Basic-Heuristics"><span>Basic Heuristics</span></a></li><li><a class="tocitem" href="#Metric-Heuristics"><span>Metric Heuristics</span></a></li><li><a class="tocitem" href="#Relaxed-Planning-Graph-Heuristics"><span>Relaxed Planning Graph Heuristics</span></a></li><li><a class="tocitem" href="#Backward-Search-Heuristics"><span>Backward Search Heuristics</span></a></li><li><a class="tocitem" href="#Wrapper-Heuristics"><span>Wrapper Heuristics</span></a></li><li><a class="tocitem" href="#Precomputation-and-Memoization"><span>Precomputation and Memoization</span></a></li></ul></li><li><a class="tocitem" href="../specifications/">Specifications</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../simulators/">Simulators</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Heuristics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Heuristics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/master/docs/src/heuristics.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Heuristics"><a class="docs-heading-anchor" href="#Heuristics">Heuristics</a><a id="Heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Heuristics" title="Permalink"></a></h1><p>SymbolicPlanners.jl provides a library of search heuristics which estimate the  distance between a state and the goal.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.Heuristic" href="#SymbolicPlanners.Heuristic"><code>SymbolicPlanners.Heuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Heuristic</code></pre><p>Abstract type for search heuristics, which estimate the distance from a  <code>State</code> to a goal specified by a <a href="../specifications/#SymbolicPlanners.Specification"><code>Specification</code></a>. Once constructed,  a <code>heuristic</code> can be called on a domain, state, and specification, returning a  <code>Real</code> number (typically <code>Float32</code> for reduced memory usage).</p><pre><code class="nohighlight hljs">heuristic(domain, state, spec; precompute=true)</code></pre><p>Heuristics may precompute and store information that will be used repeatedly during search via the <a href="#SymbolicPlanners.precompute!"><code>precompute!</code></a> method. Evaluation of the heuristic on a state is defined by <a href="#SymbolicPlanners.compute"><code>compute</code></a>.</p><p>If the <code>precompute</code> keyword argument is true when calling <code>heuristic</code> as a function, then <a href="#SymbolicPlanners.precompute!"><code>precompute!</code></a> will be called before <a href="#SymbolicPlanners.compute"><code>compute</code></a> is called to perform the heuristic evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/heuristics.jl#L5-L22">source</a></section></article><p><a href="#SymbolicPlanners.Heuristic"><code>Heuristic</code></a>s define the following interface:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.compute" href="#SymbolicPlanners.compute"><code>SymbolicPlanners.compute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute(h, domain, state, spec)
</code></pre><p>Computes the heuristic value of state relative to a goal in a given domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/heuristics.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.precompute!" href="#SymbolicPlanners.precompute!"><code>SymbolicPlanners.precompute!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">precompute!(h, domain, state, spec)
</code></pre><p>Precomputes heuristic information given a domain, state, and specification. This function is typically called once during the initialization phase of a <a href="../planners/#SymbolicPlanners.Planner"><code>Planner</code></a>&#39;s search algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/heuristics.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.is_precomputed" href="#SymbolicPlanners.is_precomputed"><code>SymbolicPlanners.is_precomputed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_precomputed(h)
</code></pre><p>Returns whether heuristic has been precomputed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/heuristics.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ensure_precomputed!" href="#SymbolicPlanners.ensure_precomputed!"><code>SymbolicPlanners.ensure_precomputed!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ensure_precomputed!(h, args)
</code></pre><p>Precomputes a heuristic if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/heuristics.jl#L48">source</a></section></article><h2 id="Basic-Heuristics"><a class="docs-heading-anchor" href="#Basic-Heuristics">Basic Heuristics</a><a id="Basic-Heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Heuristics" title="Permalink"></a></h2><p>Several basic heuristics are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.NullHeuristic" href="#SymbolicPlanners.NullHeuristic"><code>SymbolicPlanners.NullHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NullHeuristic()</code></pre><p>Null heuristic that always returns zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/basic.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.GoalCountHeuristic" href="#SymbolicPlanners.GoalCountHeuristic"><code>SymbolicPlanners.GoalCountHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GoalCountHeuristic(dir=:forward)</code></pre><p>Heuristic that counts the number of goals un/satisfied. Can be used in either the <code>:forward</code> or <code>:backward</code> direction. The latter should be used for search with <a href="../planners/#SymbolicPlanners.BackwardPlanner"><code>BackwardPlanner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/basic.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ReachabilityHeuristic" href="#SymbolicPlanners.ReachabilityHeuristic"><code>SymbolicPlanners.ReachabilityHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReachabilityHeuristic(max_steps::Int=100)</code></pre><p>Heuristic which performs a reachability analysis for the goal via abstract interpretation, returning an optimistic estimate of the number or cost of the actions required to reach the goal, or <code>Inf</code> if the goal is not reached within <code>max_steps</code> of abstract action execution.</p><p>For propositional domains (i.e. domains with no non-Boolean fluents), this returns the same value as <a href="#SymbolicPlanners.HMax"><code>HMax</code></a>. For domains with numeric fluents or other datatypes, this provides more informed estimates by performing abstract interpretation of operations on those datatypes (e.g. interval arithmetic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/reachability.jl#L3-L15">source</a></section></article><p>These heuristics are general but not very informative. As such, they are best used as baselines, or for testing the correctness of planning algorithms on small problems.</p><h2 id="Metric-Heuristics"><a class="docs-heading-anchor" href="#Metric-Heuristics">Metric Heuristics</a><a id="Metric-Heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Metric-Heuristics" title="Permalink"></a></h2><p>In domains with numeric fluents, distance metrics can be used as heuristics for goals with equality constraints:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.MetricHeuristic" href="#SymbolicPlanners.MetricHeuristic"><code>SymbolicPlanners.MetricHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MetricHeuristic(metric, fluents[, coeffs])</code></pre><p>Heuristic that computes a <code>metric</code> distance between the current state and the  goals for the specified numeric <code>fluents</code>, which are (optionally) multiplied by scalar <code>coeffs</code> before metric computation.</p><p>This heuristic can only be used with goal formulae that contain a list of  equality constraints for the provided <code>fluents</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>metric</code></p><p>Function that returns a scalar value given a vector of differences between the fluent values for the current state and the goal.</p></li><li><p><code>fluents</code></p><p>A list of <code>Term</code>s that refer to numeric fluents in the state.</p></li><li><p><code>coeffs</code></p><p>A list of scalar coefficients which each fluent value will be multiplied  by before metric computation. Defaults to <code>1</code> for all fluents.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/metric.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ManhattanHeuristic" href="#SymbolicPlanners.ManhattanHeuristic"><code>SymbolicPlanners.ManhattanHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManhattanHeuristic(fluents[, coeffs])</code></pre><p>Computes Manhattan distance to the goal for the specified numeric fluents. An instance of <a href="#SymbolicPlanners.MetricHeuristic"><code>MetricHeuristic</code></a> which uses the L1 norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/metric.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.EuclideanHeuristic" href="#SymbolicPlanners.EuclideanHeuristic"><code>SymbolicPlanners.EuclideanHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EuclideanHeuristic(fluents[, coeffs])</code></pre><p>Computes Euclidean distance to the goal for the specified numeric fluents. An instance of <a href="#SymbolicPlanners.MetricHeuristic"><code>MetricHeuristic</code></a> which uses the L2 norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/metric.jl#L85-L90">source</a></section></article><h2 id="Relaxed-Planning-Graph-Heuristics"><a class="docs-heading-anchor" href="#Relaxed-Planning-Graph-Heuristics">Relaxed Planning Graph Heuristics</a><a id="Relaxed-Planning-Graph-Heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Relaxed-Planning-Graph-Heuristics" title="Permalink"></a></h2><p>Several relaxed planning graph heuristics are provided by SymbolicPlanners.jl. In contrast to most other planning systems, these implementations also support  domains with non-Boolean fluents.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.HSPHeuristic" href="#SymbolicPlanners.HSPHeuristic"><code>SymbolicPlanners.HSPHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HSPHeuristic(op::Function)</code></pre><p>A family of relaxed planning graph heuristics, introduced by the HSP  planner [1]. The heuristic precomputes a graph that stores the dependencies between all ground actions and plan-relevant conditions. The cost of achieving each action  (and also the goal) is then recursively estimated as the aggregated cost of achieving each (pre)condition the action or goal depends upon, where <code>op</code> is an aggregation function (e.g. <code>maximum</code> or <code>sum</code>).</p><p>In turn, the cost of achieving each condition (a.k.a. &quot;fact&quot;) is estimated as the minimum cost among all actions that achieve that condition. Once a condition is achieved by an action, it is considered to remain true through the rest of the process, hence the relaxed nature of the heuristic.</p><p>This implementation supports domains with negative preconditions, disjunctive preconditions (i.e., <code>or</code>, <code>exists</code>), and functional preconditions (e.g. numeric comparisons, or other Boolean-valued functions of non-Boolean fluents). Functional preconditions are handled by (optimistically) assuming they become true once a constituent fluent is modified by some action.</p><p>[1] B. Bonet and H. Geffner, &quot;Planning as Heuristic Search,&quot; Artificial Intelligence, vol. 129, no. 1, pp. 5–33, Jun. 2001, <a href="https://doi.org/10.1016/S0004-3702(01)00108-4">https://doi.org/10.1016/S0004-3702(01)00108-4</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/hsp.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.HMax" href="#SymbolicPlanners.HMax"><code>SymbolicPlanners.HMax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HMax()</code></pre><p><a href="#SymbolicPlanners.HSPHeuristic"><code>HSPHeuristic</code></a> where an action&#39;s cost is the <code>maximum</code> cost of the  conditions it depends upon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/hsp.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.HAdd" href="#SymbolicPlanners.HAdd"><code>SymbolicPlanners.HAdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HAdd()</code></pre><p><a href="#SymbolicPlanners.HSPHeuristic"><code>HSPHeuristic</code></a> where an action&#39;s cost is the <code>sum</code>` of costs of the  conditions it depends upon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/hsp.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.FFHeuristic" href="#SymbolicPlanners.FFHeuristic"><code>SymbolicPlanners.FFHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FFHeuristic()</code></pre><p>A relaxed planning graph heuristic introduced by the FastForward planner [1].  Similar to <a href="#SymbolicPlanners.HSPHeuristic"><code>HSPHeuristic</code></a>, this heuristic precomputes a graph that stores the dependencies between all ground actions and plan-relevant conditions.</p><p>To estimate the distance to the goal, a shortest-path search is performed in the graph, starting from the conditions that are true in the current state, and  ending when all the goal conditions are reached. Once a condition is achieved by an action, it is considered to remain true through the rest of the search, hence the relaxed nature of the heuristic. A plan that achieves the goal conditions is reconstructed by following the action back-pointers for each achieved condition, and the cost of this plan is used as the heuristic estimate.</p><p>This implementation supports domains with negative preconditions, disjunctive preconditions (i.e., <code>or</code>, <code>exists</code>), and functional preconditions (e.g. numeric comparisons, or other Boolean-valued functions of non-Boolean fluents). Functional preconditions are handled by (optimistically) assuming they become true once a constituent fluent is modified by some action.</p><p>[1] J. Hoffmann, &quot;FF: The Fast-Forward Planning System,&quot; AI Magazine, vol. 22, no. 3, pp. 57–57, Sep. 2001, <a href="https://doi.org/10.1609/aimag.v22i3.1572">https://doi.org/10.1609/aimag.v22i3.1572</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/ff.jl#L4-L27">source</a></section></article><h2 id="Backward-Search-Heuristics"><a class="docs-heading-anchor" href="#Backward-Search-Heuristics">Backward Search Heuristics</a><a id="Backward-Search-Heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Search-Heuristics" title="Permalink"></a></h2><p>A few relaxed planning graph heuristics are also provided for backward search:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.HSPRHeuristic" href="#SymbolicPlanners.HSPRHeuristic"><code>SymbolicPlanners.HSPRHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HSPRHeuristic(op::Function)</code></pre><p>A family of relaxed planning graph heuristics for backward search, introduced by the HSPr planner (&quot;r&quot; stands for regression) [1]. The costs of achieving  a condition are estimated in the same way as the forward variant,  <a href="#SymbolicPlanners.HSPHeuristic"><code>HSPHeuristic</code></a>, but this estimation is performed only once during  heuristic precomputation. During heuristic evaluation, the cost from the current partial state to the start state is estimated as the aggregated cost of each condition that is true in the partial state.</p><p>[1] B. Bonet and H. Geffner, &quot;Planning as Heuristic Search,&quot; Artificial Intelligence, vol. 129, no. 1, pp. 5–33, Jun. 2001, <a href="https://doi.org/10.1016/S0004-3702(01)00108-4">https://doi.org/10.1016/S0004-3702(01)00108-4</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/hsp.jl#L97-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.HMaxR" href="#SymbolicPlanners.HMaxR"><code>SymbolicPlanners.HMaxR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HMaxR()</code></pre><p><a href="#SymbolicPlanners.HSPRHeuristic"><code>HSPRHeuristic</code></a> for backward search, where an action&#39;s cost is the <code>maximum</code> cost of its dependencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/hsp.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.HAddR" href="#SymbolicPlanners.HAddR"><code>SymbolicPlanners.HAddR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HAddR()</code></pre><p><a href="#SymbolicPlanners.HSPRHeuristic"><code>HSPRHeuristic</code></a> for backward search, where an action&#39;s cost is the <code>sum</code> of costs of its dependencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/hsp.jl#L127-L132">source</a></section></article><h2 id="Wrapper-Heuristics"><a class="docs-heading-anchor" href="#Wrapper-Heuristics">Wrapper Heuristics</a><a id="Wrapper-Heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-Heuristics" title="Permalink"></a></h2><p>Since plans and policies can be used to estimate the cost of achieving a goal,  the following wrapper heuristics are provided.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.PlannerHeuristic" href="#SymbolicPlanners.PlannerHeuristic"><code>SymbolicPlanners.PlannerHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlannerHeuristic(planner, [d_transform, s_transform])</code></pre><p>Computes distance to the goal based on the solution returned by <code>planner</code>.</p><p>If an <a href="../solutions/#SymbolicPlanners.OrderedSolution"><code>OrderedSolution</code></a> is returned, the cost of solution is used as the heuristic estimate, (plus the heuristic value of final state, if the  planner is a <a href="../planners/#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>.)</p><p>If a <a href="../solutions/#SymbolicPlanners.PolicySolution"><code>PolicySolution</code></a> is returned, the negated value (returned by <a href="../solutions/#SymbolicPlanners.get_value"><code>get_value</code></a>) is used as the heuristic estimate.</p><p>If <code>d_transform</code> or <code>s_transform</code> are provided, this transforms the input domain or state it is passed to the <code>planner</code>. This can be used to relax the  problem (e.g. by simplifying the domain, or adding / deleting predicates in the state).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/planner.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.PolicyValueHeuristic" href="#SymbolicPlanners.PolicyValueHeuristic"><code>SymbolicPlanners.PolicyValueHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolicyValueHeuristic(policy::PolicySolution)</code></pre><p>Wraps a <code>policy</code>, and returns the negated value estimate of a state  (provided by <a href="../solutions/#SymbolicPlanners.get_value"><code>get_value</code></a>) as the heuristic goal-distance estimate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/policy.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.GoalDependentPolicyHeuristic" href="#SymbolicPlanners.GoalDependentPolicyHeuristic"><code>SymbolicPlanners.GoalDependentPolicyHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GoalDependentPolicyHeuristic(policies::Dict, [default])</code></pre><p>Wraps a dictionary mapping planning <a href="../specifications/#SymbolicPlanners.Specification"><code>Specification</code></a>s to  <a href="../solutions/#SymbolicPlanners.PolicySolution"><code>PolicySolution</code></a>s. Given a particular specification, the heuristic looks up the corresponding policy and returns its negated estimate of a state&#39;s value as the heuristic goal-distance estimate.</p><p>If a <code>default</code> is provided, then this is used to construct a new policy <code>policy = default(domain, state, spec)</code> for a specification <code>spec</code> that is not found in the dictionary. Otherwise, an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/policy.jl#L16-L27">source</a></section></article><h2 id="Precomputation-and-Memoization"><a class="docs-heading-anchor" href="#Precomputation-and-Memoization">Precomputation and Memoization</a><a id="Precomputation-and-Memoization-1"></a><a class="docs-heading-anchor-permalink" href="#Precomputation-and-Memoization" title="Permalink"></a></h2><p>Some applications of planning algorithms require repeated calls to a planner (e.g. in <a href="https://dl.acm.org/doi/abs/10.5555/3495724.3497338">Bayesian inverse planning</a>), which may lead to repeated pre-computation of the search heuristic. In such cases, overhead can be substantially reduced by ensuring that precomputation happens only once. This can be done using the <a href="#SymbolicPlanners.precomputed"><code>precomputed</code></a> function to construct a <a href="#SymbolicPlanners.PrecomputedHeuristic"><code>PrecomputedHeuristic</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.precomputed" href="#SymbolicPlanners.precomputed"><code>SymbolicPlanners.precomputed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">precomputed(h::Heuristic, domain::Domain, args...)</code></pre><p>Precomputes a heuristic in advance, returning a <a href="#SymbolicPlanners.PrecomputedHeuristic"><code>PrecomputedHeuristic</code></a> that prevents repeated pre-computation later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/precomputed.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.PrecomputedHeuristic" href="#SymbolicPlanners.PrecomputedHeuristic"><code>SymbolicPlanners.PrecomputedHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrecomputedHeuristic(heuristic::Heuristic, args...)</code></pre><p>Wraps an existing <code>heuristic</code> and ensures that it is precomputed, preventing repeated pre-computation on subsequent calls to <a href="#SymbolicPlanners.precompute!"><code>precompute!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/precomputed.jl#L3-L8">source</a></section></article><p>Similarly, if heuristic computation is costly, memoization of heuristic values can lead to faster results. This can be achieved using the <a href="#SymbolicPlanners.memoized"><code>memoized</code></a> function to construct a <a href="#SymbolicPlanners.MemoizedHeuristic"><code>MemoizedHeuristic</code></a></p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.memoized" href="#SymbolicPlanners.memoized"><code>SymbolicPlanners.memoized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">memoized(h::Heuristic)</code></pre><p>Constructs a memoized version of <code>h</code> which caches outputs in a hash table after each evaluation of the heuristic on a new domain, state, or specification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/memoized.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.MemoizedHeuristic" href="#SymbolicPlanners.MemoizedHeuristic"><code>SymbolicPlanners.MemoizedHeuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MemoizedHeuristic(heuristic::Heuristic)</code></pre><p>Wraps an existing heuristic and memoizes heuristic evaluations in a hash table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6ea44b7724fee2faa6291abd1f2fd870165d66d8/src/heuristics/memoized.jl#L3-L7">source</a></section></article><p>In cases where both precomputation and memoization are desired, users should perform precomputation before memoization:</p><pre><code class="language-julia hljs">heuristic = memoized(precomputed(heuristic))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../planners/">« Planners</a><a class="docs-footer-nextpage" href="../specifications/">Specifications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Monday 29 May 2023 18:04">Monday 29 May 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
