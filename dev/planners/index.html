<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Planners · SymbolicPlanners.jl</title><meta name="title" content="Planners · SymbolicPlanners.jl"/><meta property="og:title" content="Planners · SymbolicPlanners.jl"/><meta property="twitter:title" content="Planners · SymbolicPlanners.jl"/><meta name="description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="og:description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="twitter:description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="og:url" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/planners/"/><meta property="twitter:url" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/planners/"/><link rel="canonical" href="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/planners/"/><meta property="og:image" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/assets/preview.png"/><meta property="twitter:image" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SymbolicPlanners.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicPlanners.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Planners</a><ul class="internal"><li><a class="tocitem" href="#Breadth-First-Search"><span>Breadth-First Search</span></a></li><li><a class="tocitem" href="#Forward-Heuristic-Search"><span>Forward Heuristic Search</span></a></li><li><a class="tocitem" href="#Backward-Heuristic-Search"><span>Backward Heuristic Search</span></a></li><li><a class="tocitem" href="#Bidirectional-Search"><span>Bidirectional Search</span></a></li><li><a class="tocitem" href="#Policy-Based-Planners"><span>Policy-Based Planners</span></a></li><li><a class="tocitem" href="#External-Planners"><span>External Planners</span></a></li></ul></li><li><a class="tocitem" href="../heuristics/">Heuristics</a></li><li><a class="tocitem" href="../specifications/">Specifications</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../simulators/">Simulators</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Planners</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Planners</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/master/docs/src/planners.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Planners"><a class="docs-heading-anchor" href="#Planners">Planners</a><a id="Planners-1"></a><a class="docs-heading-anchor-permalink" href="#Planners" title="Permalink"></a></h1><p>The core of <strong>SymbolicPlanners.jl</strong> is a library of planning algorithms, or  <a href="#SymbolicPlanners.Planner"><code>Planner</code></a>s:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.Planner" href="#SymbolicPlanners.Planner"><code>SymbolicPlanners.Planner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Planner</code></pre><p>Abstract planner type. Once constructed, a <code>planner</code> can be run on a <code>domain</code>, initial <code>state</code>, and a <code>spec</code>, returning a <a href="../solutions/#SymbolicPlanners.Solution"><code>Solution</code></a>. A <code>problem</code> can be provided instead of a <code>state</code> and <code>spec</code>:</p><pre><code class="nohighlight hljs">planner(domain::Domain, state::State, spec)
planner(domain::Domain, problem::Problem)</code></pre><p>New planners should define <a href="#SymbolicPlanners.solve"><code>solve</code></a> and (optionally) <a href="#SymbolicPlanners.refine!"><code>refine!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/planners.jl#L4-L15">source</a></section></article><p><a href="#SymbolicPlanners.Planner"><code>Planner</code></a>s define the following interface:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.solve" href="#SymbolicPlanners.solve"><code>SymbolicPlanners.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve(planner::Planner, domain::Domain, state::State, spec::Specification)</code></pre><p>Solve a planning problem using the specified <code>planner</code>.</p><p>New subtypes of <a href="#SymbolicPlanners.Planner"><code>Planner</code></a> should implement this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/planners.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.refine!" href="#SymbolicPlanners.refine!"><code>SymbolicPlanners.refine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refine!(sol::Solution, planner::Planner, domain::Domain, state::State, spec)</code></pre><p>Refine an existing solution (<code>sol</code>) to a planning problem (in-place). The <code>spec</code> argument can be provided as a <code>Specification</code> or as one or more goal <code>Term</code>s to be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/planners.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.refine" href="#SymbolicPlanners.refine"><code>SymbolicPlanners.refine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refine(sol::Solution, planner::Planner, domain::Domain, state::State, spec)</code></pre><p>Refine a copy of an existing solution to a planning problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/planners.jl#L54-L58">source</a></section></article><h2 id="Breadth-First-Search"><a class="docs-heading-anchor" href="#Breadth-First-Search">Breadth-First Search</a><a id="Breadth-First-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Breadth-First-Search" title="Permalink"></a></h2><p>As a baseline uninformed planning algorithm, one can use  <a href="#SymbolicPlanners.BreadthFirstPlanner"><code>BreadthFirstPlanner</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BreadthFirstPlanner" href="#SymbolicPlanners.BreadthFirstPlanner"><code>SymbolicPlanners.BreadthFirstPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BreadthFirstPlanner(;
    max_nodes::Int = typemax(Int),
    max_time::Float64 = Inf,
    save_search::Bool = false,
    save_search_order::Bool = save_search,
    verbose::Bool = false,
    callback = verbose ? LoggerCallback() : nothing
)</code></pre><p>Breadth-first search planner. Nodes are expanded in order of increasing distance from the initial state (skipping previously visited nodes).</p><p>Returns a <a href="../solutions/#SymbolicPlanners.PathSearchSolution"><code>PathSearchSolution</code></a> or <a href="../solutions/#SymbolicPlanners.NullSolution"><code>NullSolution</code></a>, similar to <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>max_nodes</code>: Maximum number of search nodes before termination.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>save_search</code>: Flag to save the search tree and frontier in the returned solution.</p></li><li><p><code>save_search_order</code>: Flag to save the node expansion order in the returned solution.</p></li><li><p><code>verbose</code>: Flag to print debug information during search.</p></li><li><p><code>callback</code>: Callback function for logging, etc.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/bfs.jl#L3-L22">source</a></section></article><p>Note that <a href="#SymbolicPlanners.BreadthFirstPlanner"><code>BreadthFirstPlanner</code></a> will ignore plan metrics or action costs, returning a plan that has the shortest number of steps, but not necessarily the lowest cost.</p><h2 id="Forward-Heuristic-Search"><a class="docs-heading-anchor" href="#Forward-Heuristic-Search">Forward Heuristic Search</a><a id="Forward-Heuristic-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Heuristic-Search" title="Permalink"></a></h2><p>The modern day workhorse for automated planning is forward heuristic search, implemented by <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ForwardPlanner" href="#SymbolicPlanners.ForwardPlanner"><code>SymbolicPlanners.ForwardPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardPlanner(;
    heuristic::Heuristic = GoalCountHeuristic(),
    search_noise::Union{Nothing,Float64} = nothing,
    g_mult::Float32 = 1.0f0,
    h_mult::Float32 = 1.0f0,
    max_nodes::Int = typemax(Int),
    max_time::Float64 = Inf,
    fail_fast::Bool = false,
    refine_method::Symbol = :continue,
    reset_node_count::Bool = true,
    save_search::Bool = true,
    save_search_order::Bool = true,
    save_parents::Bool = false,
    save_children::Bool = false,
    verbose::Bool = false,
    callback = verbose ? LoggerCallback() : nothing
)</code></pre><p>Forward best-first search planner, which encompasses uniform-cost search, greedy search, and A* search. Each node <span>$n$</span> is expanded in order of increasing priority <span>$f(n)$</span>, defined as:</p><p class="math-container">\[f(n) = g_\text{mult} \cdot g(n) + h_\text{mult} \cdot h(n)\]</p><p>where <span>$g(n)$</span> is the path cost from the initial state to <span>$n$</span>, and <span>$h(n)$</span> is the heuristic&#39;s goal distance estimate.</p><p>Returns a <a href="../solutions/#SymbolicPlanners.PathSearchSolution"><code>PathSearchSolution</code></a> if the goal is achieved, containing a plan that reaches the goal node, and <code>status</code> set to <code>:success</code>. If the node or time budget runs out, the solution will instead contain a partial plan to the last node selected for expansion, with <code>status</code> set to <code>:max_nodes</code> or <code>:max_time</code> accordingly.</p><p>If <code>save_search</code> is true, the returned solution will contain the search tree and frontier so far. If <code>save_search</code> is true and the search space is exhausted return a <code>NullSolution</code> with <code>status</code> set to <code>:failure</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>heuristic</code>: Search heuristic that estimates cost of a state to the goal.</p></li><li><p><code>search_noise</code>: Amount of Boltzmann search noise (<code>nothing</code> for deterministic search).</p></li><li><p><code>g_mult</code>: Path cost multiplier when computing the <span>$f$</span> value of a search node.</p></li><li><p><code>h_mult</code>: Heuristic multiplier when computing the <span>$f$</span> value of a search node.</p></li><li><p><code>max_nodes</code>: Maximum number of search nodes before termination.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>fail_fast</code>: Flag to terminate search if the heuristic estimates an infinite cost.</p></li><li><p><code>refine_method</code>: Solution refinement method (one of <code>:continue</code>, <code>:reroot</code>, <code>:restart</code>)</p></li><li><p><code>reset_node_count</code>: Whether to reset the expanded node count before solution refinement.</p></li><li><p><code>save_search</code>: Flag to save the search tree and frontier (needed for refinement).</p></li><li><p><code>save_search_order</code>: Flag to save the node expansion order in the solution.</p></li><li><p><code>save_parents</code>: Flag to save all parent pointers in search tree (needed for rerooting).</p></li><li><p><code>save_children</code>: Flag to save all children pointers in search tree (needed for rerooting).</p></li><li><p><code>verbose</code>: Flag to print debug information during search.</p></li><li><p><code>callback</code>: Callback function for logging, etc.</p></li></ul><p><strong>Refinement Methods</strong></p><p>Setting the <code>refine_method</code> keyword argument controls the behavior of <a href="#SymbolicPlanners.refine!"><code>refine!</code></a> when called on a <a href="../solutions/#SymbolicPlanners.PathSearchSolution"><code>PathSearchSolution</code></a>:</p><ul><li><p><code>:continue</code> (default): Continues the search by expanding the search tree rooted at the original starting state. <code>save_search</code> will default to <code>true</code> if this method is used.</p></li><li><p><code>:reroot</code>: Reroots the search tree at the newly-provided starting state, then continues the search, as in Fringe-Retrieving A* [1]. <code>save_search</code>, <code>save_parents</code>, and <code>save_children</code> will default to <code>true</code> if this method is used.</p></li><li><p><code>:restart</code>: Restarts the search from the new starting state, throwing away the  previous search tree and frontier. This is the only valid refinement method when <code>save_search</code> is <code>false</code>.</p></li></ul><p>[1] X. Sun, W. Yeoh, and S. Koenig, “Generalized Fringe-Retrieving A*: Faster moving target search on state lattices,” AAMAS (2010), pp. 1081-1088. <a href="https://dl.acm.org/doi/abs/10.5555/1838206.1838352">https://dl.acm.org/doi/abs/10.5555/1838206.1838352</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/forward.jl#L5-L70">source</a></section></article><p>Several convenience constructors for variants of <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a> are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.UniformCostPlanner" href="#SymbolicPlanners.UniformCostPlanner"><code>SymbolicPlanners.UniformCostPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">UniformCostPlanner(; kwargs...)
</code></pre><p>Uniform-cost search. Nodes with the lowest path cost from the initial state are expanded first (i.e. the search heuristic is not used).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/forward.jl#L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.GreedyPlanner" href="#SymbolicPlanners.GreedyPlanner"><code>SymbolicPlanners.GreedyPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">GreedyPlanner(heuristic; kwargs...)
</code></pre><p>Greedy best-first search, with cycle checking. Nodes with the lowest heuristic value are expanded first (i.e. the cost of reaching them from the initial state is ignored).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/forward.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.AStarPlanner" href="#SymbolicPlanners.AStarPlanner"><code>SymbolicPlanners.AStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AStarPlanner(heuristic; kwargs...)
</code></pre><p>A* search. Nodes with the lowest <span>$f$</span> value are expanded first. This is guaranteed to produce a cost-optimal solution if the <code>heuristic</code> is admissible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/forward.jl#L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.WeightedAStarPlanner" href="#SymbolicPlanners.WeightedAStarPlanner"><code>SymbolicPlanners.WeightedAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">WeightedAStarPlanner(heuristic, h_mult; kwargs...)
</code></pre><p>Weighted A* search, which multiplies the heuristic estimate by <code>h_mult</code> when computing the <span>$f$</span> value of a node. Nodes with the lowest <span>$f$</span> value are expanded first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/forward.jl#L146">source</a></section></article><p>Probabilistic variants of forward search are also provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ProbForwardPlanner" href="#SymbolicPlanners.ProbForwardPlanner"><code>SymbolicPlanners.ProbForwardPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProbForwardPlanner(;
    search_noise::Float64 = 1.0,
    kwargs...
)</code></pre><p>A probabilistic variant of forward best-first search. Instead of always expanding the node with lowest <span>$f$</span> value in the search frontier, this samples a node to expand according to Boltzmann distribution, where the <span>$f$</span> value of a frontier node is treated as the unnormalized log probability of expansion.</p><p>The temperature for Boltzmann sampling is defined by <code>search_noise</code>. Higher values lead to more random search, lower values lead to more deterministic search.</p><p>Useful for simulating a diversity of potentially sub-optimal plans, especially when paired with a limited <code>max_nodes</code> budget.</p><p>An alias for <code>ForwardPlanner{Float64}</code>. See <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a> for other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/forward.jl#L156-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ProbAStarPlanner" href="#SymbolicPlanners.ProbAStarPlanner"><code>SymbolicPlanners.ProbAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ProbAStarPlanner(heuristic; search_noise, kwargs...)
</code></pre><p>A probabilistic variant of A* search. See <a href="#SymbolicPlanners.ProbForwardPlanner"><code>ProbForwardPlanner</code></a> for how nodes are probabilistically expanded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/forward.jl#L182">source</a></section></article><h2 id="Backward-Heuristic-Search"><a class="docs-heading-anchor" href="#Backward-Heuristic-Search">Backward Heuristic Search</a><a id="Backward-Heuristic-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Heuristic-Search" title="Permalink"></a></h2><p>Due to the flexibility of the PDDL.jl API, <strong>SymbolicPlanners.jl</strong> supports backward search:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BackwardPlanner" href="#SymbolicPlanners.BackwardPlanner"><code>SymbolicPlanners.BackwardPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackwardPlanner(;
    heuristic::Heuristic = GoalCountHeuristic(:backward),
    search_noise::Union{Nothing,Float64} = nothing,
    g_mult::Float32 = 1.0f0,
    h_mult::Float32 = 1.0f0,
    max_nodes::Int = typemax(Int),
    max_time::Float64 = Inf,
    fail_fast::Bool = false,
    save_search::Bool = false,
    save_search_order::Bool = save_search,
    verbose::Bool = false,
    callback = verbose ? LoggerCallback() : nothing
)</code></pre><p>Heuristic-guided backward (i.e. regression) search planner. Instead of searching forwards, searches backwards from the goal, which is treated as a <em>set</em> of  states which satisfy the goal predicates (equivalently, a <em>partial</em> state,  because only some predicates and fluents may be specified). Each expanded node also corresponds to a partial state. [1]</p><p>As with <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>, each node <span>$n$</span> is expanded in order of increasing priority <span>$f(n)$</span>, defined as:</p><p class="math-container">\[f(n) = g_\text{mult} \cdot g(n) + h_\text{mult} \cdot h(n)\]</p><p>However <span>$g(n)$</span> is instead defined as the path cost from the goal to the current node <span>$n$</span>, and <span>$h(n)$</span> is a heuristic estimate of the distance from the initial state. As such, only certain heuristics, such as <a href="../heuristics/#SymbolicPlanners.GoalCountHeuristic"><code>GoalCountHeuristic</code></a> and  <a href="../heuristics/#SymbolicPlanners.HSPRHeuristic"><code>HSPRHeuristic</code></a> can be used with backward search.</p><p>Returns a <a href="../solutions/#SymbolicPlanners.PathSearchSolution"><code>PathSearchSolution</code></a> or <a href="../solutions/#SymbolicPlanners.NullSolution"><code>NullSolution</code></a>, similar to <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>.</p><p>This planner does not currently support domains with non-Boolean fluents or  problems involving constraint specifications.</p><p>[1] B. Bonet and H. Geffner, &quot;Planning as Heuristic Search,&quot; Artificial Intelligence, vol. 129, no. 1, pp. 5–33, Jun. 2001, <a href="https://doi.org/10.1016/S0004-3702(01)00108-4">https://doi.org/10.1016/S0004-3702(01)00108-4</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>heuristic</code>: Search heuristic that estimates cost of a state to the goal.</p></li><li><p><code>search_noise</code>: Amount of Boltzmann search noise (<code>nothing</code> for deterministic search).</p></li><li><p><code>g_mult</code>: Path cost multiplier when computing the <span>$f$</span> value of a search node.</p></li><li><p><code>h_mult</code>: Heuristic multiplier when computing the <span>$f$</span> value of a search node.</p></li><li><p><code>max_nodes</code>: Maximum number of search nodes before termination.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>fail_fast</code>: Flag to terminate search if the heuristic estimates an infinite cost.</p></li><li><p><code>save_search</code>: Flag to save the search tree and frontier in the returned solution.</p></li><li><p><code>save_search_order</code>: Flag to save the node expansion order in the returned solution.</p></li><li><p><code>verbose</code>: Flag to print debug information during search.</p></li><li><p><code>callback</code>: Callback function for logging, etc.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/backward.jl#L4-L51">source</a></section></article><p>The following convenience constructors are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BackwardGreedyPlanner" href="#SymbolicPlanners.BackwardGreedyPlanner"><code>SymbolicPlanners.BackwardGreedyPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BackwardGreedyPlanner(heuristic; kwargs...)
</code></pre><p>Backward greedy search, with cycle checking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/backward.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BackwardAStarPlanner" href="#SymbolicPlanners.BackwardAStarPlanner"><code>SymbolicPlanners.BackwardAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BackwardAStarPlanner(heuristic; kwargs...)
</code></pre><p>Backward A* search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/backward.jl#L91">source</a></section></article><p>As with <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>, probabilistic variants of backward search are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ProbBackwardPlanner" href="#SymbolicPlanners.ProbBackwardPlanner"><code>SymbolicPlanners.ProbBackwardPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProbBackwardPlanner(;
    search_noise::Float64 = 1.0,
    kwargs...
)</code></pre><p>A probabilistic variant of backward search, with the same node expansion rule as <a href="#SymbolicPlanners.ProbForwardPlanner"><code>ProbForwardPlanner</code></a>.</p><p>An alias for <code>BackwardPlanner{Float64}</code>. See <a href="#SymbolicPlanners.BackwardPlanner"><code>BackwardPlanner</code></a> for other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/backward.jl#L99-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ProbBackwardAStarPlanner" href="#SymbolicPlanners.ProbBackwardAStarPlanner"><code>SymbolicPlanners.ProbBackwardAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ProbBackwardAStarPlanner(heuristic; search_noise, kwargs...)
</code></pre><p>A probabilistic variant of backward A* search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/backward.jl#L116">source</a></section></article><h2 id="Bidirectional-Search"><a class="docs-heading-anchor" href="#Bidirectional-Search">Bidirectional Search</a><a id="Bidirectional-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Bidirectional-Search" title="Permalink"></a></h2><p>A simple implementation of bidirectional search is provided by  <a href="#SymbolicPlanners.BidirectionalPlanner"><code>BidirectionalPlanner</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BidirectionalPlanner" href="#SymbolicPlanners.BidirectionalPlanner"><code>SymbolicPlanners.BidirectionalPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">planner = BidirectionalPlanner(;
    forward::ForwardPlanner = ForwardPlanner(),
    backward::BackwardPlanner = BackwardPlanner(),
    max_nodes::Int = typemax(Int),
    max_time::Float64 = Inf,
    save_search::Bool = false
)</code></pre><p>A bi-directional planner which simulataneously runs a forward search from the initial state and backward search from the goal, succeeding if either search is successful, or if the search frontiers are detected to cross.</p><p>Frontier crossing is detected by checking whether the most recently expanded forward node is subsumed by a node in the backward search frontier, or vice versa. Subsumption means that the partial state represented by a backward node is consistent with the complete state represented by forward node.</p><p>While the above procedure is not complete (i.e. some crossings will be missed), it represents a trade-off between the cost of testing for subsumption and the  benefit of detecting a crossing, in lieu of more sophisticated methods [1].</p><p>[1] V. Alcázar, S. Fernández, and D. Borrajo, &quot;Analyzing the Impact of Partial States on Duplicate Detection and Collision of Frontiers,&quot; ICAPS (2014), <a href="https://doi.org/10.1609/icaps.v24i1.13677">https://doi.org/10.1609/icaps.v24i1.13677</a></p><p><strong>Arguments</strong></p><ul><li><p><code>forward</code>: Forward search configuration.</p></li><li><p><code>backward</code>: Forward search configuration.</p></li><li><p><code>max_nodes</code>: Maximum number of search nodes before termination.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>save_search</code>: Flag to save the search tree and frontier in the returned solution.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/bidirectional.jl#L3-L32">source</a></section></article><p>The following convenience constructors are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BiGreedyPlanner" href="#SymbolicPlanners.BiGreedyPlanner"><code>SymbolicPlanners.BiGreedyPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiGreedyPlanner(f_heuristic, b_heuristic; kwargs...)
</code></pre><p>Bidirectional greedy best-first search, where <code>f_heuristic</code> is the forward search heuristic and <code>b_heuristic</code><code>is the backward search heuristic. Options specified as</code>kwargs` are shared by both the backward and forward search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/bidirectional.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BiAStarPlanner" href="#SymbolicPlanners.BiAStarPlanner"><code>SymbolicPlanners.BiAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiAStarPlanner(f_heuristic, b_heuristic; kwargs...)
</code></pre><p>Bidirectional A* search, where <code>f_heuristic</code> is the forward search heuristic and <code>b_heuristic</code><code>is the backward search heuristic. Options specified as</code>kwargs` are shared by both the backward and forward search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/bidirectional.jl#L84">source</a></section></article><h2 id="Policy-Based-Planners"><a class="docs-heading-anchor" href="#Policy-Based-Planners">Policy-Based Planners</a><a id="Policy-Based-Planners-1"></a><a class="docs-heading-anchor-permalink" href="#Policy-Based-Planners" title="Permalink"></a></h2><p>Unlike most systems for automated symbolic planning, <strong>SymbolicPlanners.jl</strong> includes several policy-based planners which return <a href="../solutions/#SymbolicPlanners.PolicySolution"><code>PolicySolution</code></a>s.</p><p>These planners are especially useful for stochastic environments (even if the planner operates over a determinized version of the true domain), since they compute what action should be performed in each encountered state, rather than just a sequence of ordered actions. They are also useful for real-time planning via reuse of previous solutions.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.RealTimeDynamicPlanner" href="#SymbolicPlanners.RealTimeDynamicPlanner"><code>SymbolicPlanners.RealTimeDynamicPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RealTimeDynamicPlanner(;
    heuristic::Heuristic = GoalCountHeuristic(),
    n_rollouts::Int = 50,
    max_depth::Int = 50,
    rollout_noise::Float64 = 0.0,
    action_noise::Float64 = 0.0,
    verbose::Bool = false,
    callback = verbose ? LoggerCallback() : nothing
)</code></pre><p>Planner that uses Real Time Dynamic Programming (<code>RTDP</code> for short), a form of asynchronous value iteration which performs greedy rollouts from the initial state, updating the value estimates of states encountered along the way [1].</p><p>If a <code>heuristic</code> is provided, the negated heuristic value will be used as an initial value estimate for newly encountered states (since the value of a state in a shortest path problem is the cost to reach the goal), thereby guiding early rollouts.</p><p>For admissible (i.e. optimistic) heuristics, convergence to the true value function is guaranteed in the reachable state space after a sufficient number of rollouts.</p><p>Returns a <a href="../solutions/#SymbolicPlanners.TabularPolicy"><code>TabularPolicy</code></a> (wrapped in a <a href="../solutions/#SymbolicPlanners.BoltzmannPolicy"><code>BoltzmannPolicy</code></a> if <code>action_noise &gt; 0</code>), which stores the value estimates and action Q-values for each encountered state. </p><p>[1] A. G. Barto, S. J. Bradtke, and S. P. Singh, &quot;Learning to Act using Real-Time Dynamic Programming,&quot; Artificial Intelligence, vol. 72, no. 1, pp. 81–138, Jan. 1995, <a href="https://doi.org/10.1016/0004-3702(94)00011-O">https://doi.org/10.1016/0004-3702(94)00011-O</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>heuristic</code>: Search heuristic used to initialize the value function.</p></li><li><p><code>n_rollouts</code>: Number of rollouts to perform from the initial state.</p></li><li><p><code>max_depth</code>: Maximum depth of each rollout.</p></li><li><p><code>rollout_noise</code>: Amount of Boltzmann noise during simulated rollouts.</p></li><li><p><code>action_noise</code>: Amount of Boltzmann action noise for the returned policy.</p></li><li><p><code>verbose</code>: Flag to print debug information during search.</p></li><li><p><code>callback</code>: Callback function for logging, etc.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/rtdp.jl#L3-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.RealTimeHeuristicSearch" href="#SymbolicPlanners.RealTimeHeuristicSearch"><code>SymbolicPlanners.RealTimeHeuristicSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RealTimeHeuristicSearch(;
    heuristic::Heuristic = GoalCountHeuristic(),
    n_iters::Int = 1,
    max_nodes::Int = 50,
    update_method::Symbol = :dijkstra,
    search_neighbors::Symbol = :unexpanded,
    save_search::Bool = true,
    reuse_search::Bool = false,
    reuse_paths::Bool = true,
    kwargs...
)

RealTimeHeuristicSearch(
    planner::ForwardPlanner,
    n_iters::Int = 1,
    update_method::Symbol = :dijkstra,
    search_neighbors::Symbol = :unexpanded,
    reuse_search::Bool = true,
    reuse_paths::Bool = true,
)</code></pre><p>A real time heuristic search (<code>RTHS</code>) algorithm [1] similar to <code>RTDP</code>. Instead of greedy rollouts, forward heuristic search is performed from the current state (up to <code>max_nodes</code>), and value estimates are updated for all states in the interior of the search tree. Search may also be performed from neighboring states by configuring <code>search_neighbors</code>. A simulated action is then taken to the best neighboring state. This process repeats for <code>n_iters</code>, with future searches using the updated value function as a more informed heuristic.</p><p>Returns a <a href="../solutions/#SymbolicPlanners.ReusableTreePolicy"><code>ReusableTreePolicy</code></a>, containing a <a href="../solutions/#SymbolicPlanners.TabularVPolicy"><code>TabularVPolicy</code></a> of state value estimates, the most recent <a href="../solutions/#SymbolicPlanners.PathSearchSolution"><code>PathSearchSolution</code></a> produced by forward search (including a search tree if <code>save_search</code> is <code>true</code>), and a  reusable tree of goal paths if <code>reuse_paths</code> is <code>true</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>planner</code>: The <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a> used for lookahead heuristic search. Any keyword arguments accepted by <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a> are also keyword arguments for <code>RTHS</code> (e.g. <code>heuristic</code>, <code>max_nodes</code>, <code>save_search</code>, etc.).</p></li><li><p><code>n_iters</code>: Number of iterations to perform. In each iteration,  search is followed by a simulated action to the best neighboring state. If a goal or dead end is reached, we restart from the initial state.</p></li><li><p><code>update_method</code>: Method used to update value estimates, either via  cost differencing from the terminal node (<code>:costdiff</code>), or via Dijkstra&#39;s algorithm (<code>:dijkstra</code>).</p></li><li><p><code>search_neighbors</code>: Controls whether search is additionally performed from all neighbors of the current state (<code>:all</code>), from neighbors unexpanded by the initial search (<code>:unexpanded</code>), or none of them (<code>:none</code>).</p></li><li><p><code>reuse_search</code>: If <code>true</code>, then previous search solutions are reused by subsequent searches in future iterations or calls to <a href="#SymbolicPlanners.refine!"><code>refine!</code></a>. The latter requires <code>save_search</code> to be <code>true</code>. Search solutions are reused via the <code>:reroot</code> refinement method for <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>.</p></li><li><p><code>reuse_paths</code>: If <code>true</code>, then every time a path to the goal is found, it is stored in a reusable tree of goal paths, as in Tree Adaptive A* [2]. Future searches will terminate once a previous path is encountered, reducing the cost of search. A consistent <code>heuristic</code> is required to ensure path optimality.</p></li></ul><p><strong>Update Methods</strong></p><p>Setting the <code>update_method</code> keyword argument controls how value estimates <span>$V(s)$</span> (or equivalently, cost-to-goal estimates <span>$h(s) = -V(s)$</span>) are updated:</p><ul><li><p><code>:costdiff</code>: Value estimates are updated by cost differencing from the terminal node <span>$t$</span>. For each node <span>$s$</span> in the search tree&#39;s interior, we estimate the cost-to-goal <span>$h(s)$</span> by adding a lower bound on the cost from <span>$s$</span> to <span>$t$</span> to the cost-to-goal of <span>$t$</span>:</p><p class="math-container">\[h(s) = h(t) + (c(r, t) - c(r, s))\]</p><p>where <span>$c(r, s)$</span> is the cost from the root node <span>$r$</span> to <span>$s$</span>. This is the update used by Real-Time Adaptive A* [3]. Takes <span>$O(N)$</span> time, where <span>$N$</span> is the size of the tree&#39;s interior.</p></li><li><p><code>:dijkstra</code> : Value estimates are backpropagated from the search frontier via Dijkstra&#39;s algorithm. For each node <span>$s$</span> in tree&#39;s interior, we update the cost-to-goal <span>$h(s)$</span> by minimizing over all paths to the frontier:</p><p class="math-container">\[h(s) = \min_{t \in F} h(t) + c(s, t)\]</p><p>This is the update rule by LSS-LRTA* [4], which produces more informed value estimates than <code>:costdiff</code>, but takes <span>$O(NB \log NB)$</span> time. <span>$N$</span> is the size of the tree&#39;s interior and <span>$B$</span> is the maximal branching factor.  The <code>save_parents</code> keyword for <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a> defaults to <code>true</code> when this method is used.</p></li></ul><p>Both of these update methods require a <code>heuristic</code> that is initially consistent for the updated value estimates to remain consistent.</p><p>[1] R. E. Korf, &quot;Real-Time Heuristic Search,&quot; Artificial Intelligence, vol. 42, no. 2, pp. 189–211, Mar. 1990, <a href="https://doi.org/10.1016/0004-3702(90)90054-4">https://doi.org/10.1016/0004-3702(90)90054-4</a>.</p><p>[2] C. Hernández, X. Sun, S. Koenig, and P. Meseguer, &quot;Tree Adaptive A*,&quot;  AAMAS (2011), pp. 123–130. <a href="https://dl.acm.org/doi/abs/10.5555/2030470.2030488">https://dl.acm.org/doi/abs/10.5555/2030470.2030488</a>.</p><p>[3] S. Koenig and M. Likhachev, &quot;Real-Time Adaptive A*,&quot; AAMAS (2006), pp. 281–288. <a href="https://doi.org/10.1145/1160633.1160682">https://doi.org/10.1145/1160633.1160682</a>.</p><p>[4] S. Koenig and X. Sun, &quot;Comparing real-time and incremental heuristic search for real-time situated agents&quot;, AAMAS (2009), pp. 313–341. <a href="https://dl.acm.org/doi/10.5555/1018410.1018838">https://dl.acm.org/doi/10.5555/1018410.1018838</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/rths.jl#L4-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.AlternatingRealTimeHeuristicSearch" href="#SymbolicPlanners.AlternatingRealTimeHeuristicSearch"><code>SymbolicPlanners.AlternatingRealTimeHeuristicSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AlternatingRealTimeHeuristicSearch(
    planners::RealTimeHeuristicSearch...;
    share_values::Bool = true,
    share_search::Bool = false,
    share_paths::Bool = true,
)</code></pre><p>A variant of <a href="#SymbolicPlanners.RealTimeHeuristicSearch"><code>RealTimeHeuristicSearch</code></a> (<code>AlternatingRTHS</code> or <code>ARTHS</code> for short) that alternates between different search strategies, corresponding to one or more <code>planners</code>. For example, <code>ARTHS</code> can alternate between a  <code>RTHS</code> planner that uses A* search (<code>h_mult = 1.0</code>) and an <code>RTHS</code> planner that  uses breadth-first search (<code>h_mult = 0.0</code>), ensuring that the updated region  of the state space is both deep and broad.</p><p>Returns a <a href="../solutions/#SymbolicPlanners.MultiSolution"><code>MultiSolution</code></a> composed of <a href="../solutions/#SymbolicPlanners.ReusableTreePolicy"><code>ReusableTreePolicy</code></a> sub-solutions. By default, these sub-solutions share and update the same value estimates (<code>share_values = true</code>) and the same reusable tree of optimal paths to the goal (<code>share_paths = true</code>), but do not share the same reusable forward search tree (<code>share_search = false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/rths.jl#L494-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.MonteCarloTreeSearch" href="#SymbolicPlanners.MonteCarloTreeSearch"><code>SymbolicPlanners.MonteCarloTreeSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonteCarloTreeSearch(
	n_rollouts::Int64 = 50,
	max_depth::Int64 = 50,
	heuristic::Heuristic = NullHeuristic(),
	selector::MCTSNodeSelector = BoltzmannUCBSelector(),
	estimator::MCTSLeafEstimator = RandomRolloutEstimator()
end</code></pre><p>Planner that uses Monte Carlo Tree Search (<code>MCTS</code> for short) [1], with a  customizable initial value <code>heuristic</code>, node <code>selector</code> strategy, and leaf node value <code>estimator</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>n_rollouts</code>: Number of search rollouts to perform.</p></li><li><p><code>max_depth</code>: Maximum depth of rollout (including the selection and estimation phases).</p></li><li><p><code>heuristic</code>: Initial value heuristic for newly encountered states / leaf nodes.</p></li><li><p><code>selector</code>: Node selection strategy for previously visited nodes (e.g. MaxUCB).</p></li><li><p><code>estimator</code>: Estimator for leaf node values (e.g. random or policy-based rollouts).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/mcts.jl#L159-L175">source</a></section></article><h2 id="External-Planners"><a class="docs-heading-anchor" href="#External-Planners">External Planners</a><a id="External-Planners-1"></a><a class="docs-heading-anchor-permalink" href="#External-Planners" title="Permalink"></a></h2><p>Wrappers for several external planners are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.FastDownward" href="#SymbolicPlanners.FastDownward"><code>SymbolicPlanners.FastDownward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastDownward(
    search::String = &quot;astar&quot;,
    heuristic::String = &quot;add&quot;,
    h_params::Dict{String, String} = Dict(),
    max_time::Float64 = 300,
    verbose::Bool = false,
    log_stats::Bool = true,
    fd_path::String = get(ENV, &quot;FD_PATH&quot;, &quot;&quot;),
    py_cmd::String = get(ENV, &quot;PYTHON&quot;, &quot;python&quot;)
)</code></pre><p>Wrapper for the FastDownward planning system [1]. The planner has to be installed locally for this wrapper to be used. Consult the FastDownward documentation for further explanation of options.</p><p>[1] M. Helmert, &quot;The Fast Downward Planning System,&quot; Journal of Artificial Intelligence Research, vol. 26, pp. 191–246, Jul. 2006, <a href="https://doi.org/10.1613/jair.1705">https://doi.org/10.1613/jair.1705</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>search</code>: String specifying search algorithm (e.g. &quot;astar&quot;, &quot;ehc&quot;).</p></li><li><p><code>heuristic</code>: String specifying search heuristic (e.g. &quot;add&quot;, &quot;lmcut&quot;,).</p></li><li><p><code>h_params</code>: Heuristic parameters as a dictionary mapping names to values.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>verbose</code>: Flag to print planner outputs.</p></li><li><p><code>log_stats</code>: Flag to log solution statistics.</p></li><li><p><code>fd_path</code>: Path to <code>fast_downward.py</code>.</p></li><li><p><code>py_cmd</code>: Path to Python executable.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/external.jl#L55-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.Pyperplan" href="#SymbolicPlanners.Pyperplan"><code>SymbolicPlanners.Pyperplan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pyperplan(
    search::String = &quot;astar&quot;,
    heuristic::String = &quot;add&quot;,
    log_level::String = &quot;info&quot;,
    log_stats::Bool = true,
    max_time::Float64 = 300,
    verbose::Bool = false,
    py_cmd::String = get(ENV, &quot;PYTHON&quot;, &quot;python&quot;)
)</code></pre><p>Wrapper for the Pyperplan lightweight STRIPS planner [1]. The planner has to be installed locally for this wrapper to be used. Consult the Pyperplan documentation for further explanation of options.</p><p>[1] Y. Alkhazraji et al., &quot;Pyperplan.&quot; Zenodo, 2020. <a href="https://doi.org/10.5281/zenodo.3700819">https://doi.org/10.5281/zenodo.3700819</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>search</code>: String specifying search algorithm (e.g. &quot;astar&quot;, &quot;gbf&quot;).</p></li><li><p><code>heuristic</code>: String specifying search heuristic (e.g. &quot;hadd&quot;, &quot;hmax&quot;,).</p></li><li><p><code>log_level</code>: How much information to log when running the planner.</p></li><li><p><code>log_stats</code>: Flag to log solution statistics.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>verbose</code>: Flag to print planner outputs.</p></li><li><p><code>py_cmd</code>: Path to Python executable.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/external.jl#L163-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ENHSP" href="#SymbolicPlanners.ENHSP"><code>SymbolicPlanners.ENHSP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ENHSP(
    search::String = &quot;astar&quot;,
    heuristic::String = &quot;add&quot;,
    h_mult::Float64 = 1.0,
    log_stats::Bool = true,
    max_time::Float64 = 300,
    verbose::Bool = false,
    enhsp_path::String = get(ENV, &quot;ENHSP_PATH&quot;, &quot;&quot;),
    java_cmd::String = get(ENV, &quot;JAVA&quot;, &quot;java&quot;)
)</code></pre><p>Wrapper for the Expressive Numeric Heuristic Search Planner (ENHSP) [1]. The planner has to be installed locally for this wrapper to be used. Consult the ENHSP documentation for further explanation of options.</p><p>[1] E. Scala et al., &quot;ENHSP&quot;, <a href="https://sites.google.com/view/enhsp/">https://sites.google.com/view/enhsp/</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>search</code>: String specifying search algorithm (e.g. &quot;gbfs&quot;, &quot;WAStar&quot;).</p></li><li><p><code>heuristic</code>: String specifying search heuristic (e.g. &quot;hadd&quot;, &quot;aibr&quot;,).</p></li><li><p><code>h_mult</code>: Heuristic multiplier for weighted A*.</p></li><li><p><code>log_stats</code>: Flag to log solution statistics.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>verbose</code>: Flag to print planner outputs.</p></li><li><p><code>enhsp_path</code>: Path to <code>enhsp.jar</code>.</p></li><li><p><code>java_cmd</code>: Path to Java executable.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/643673133a07dd2663f7b508a6f6ca253b279541/src/planners/external.jl#L262-L283">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../heuristics/">Heuristics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Tuesday 22 April 2025 00:07">Tuesday 22 April 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
