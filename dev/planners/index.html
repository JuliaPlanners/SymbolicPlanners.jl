<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Planners · SymbolicPlanners.jl</title><meta name="title" content="Planners · SymbolicPlanners.jl"/><meta property="og:title" content="Planners · SymbolicPlanners.jl"/><meta property="twitter:title" content="Planners · SymbolicPlanners.jl"/><meta name="description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="og:description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="twitter:description" content="Documentation for SymbolicPlanners.jl, a library of planners for PDDL domains."/><meta property="og:url" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/planners/"/><meta property="twitter:url" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/planners/"/><link rel="canonical" href="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/planners/"/><meta property="og:image" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/assets/preview.png"/><meta property="twitter:image" content="https://juliaplanners.github.io/SymbolicPlanners.jl/stable/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="SymbolicPlanners.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicPlanners.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Planners</a><ul class="internal"><li><a class="tocitem" href="#Breadth-First-Search"><span>Breadth-First Search</span></a></li><li><a class="tocitem" href="#Forward-Heuristic-Search"><span>Forward Heuristic Search</span></a></li><li><a class="tocitem" href="#Backward-Heuristic-Search"><span>Backward Heuristic Search</span></a></li><li><a class="tocitem" href="#Bidirectional-Search"><span>Bidirectional Search</span></a></li><li><a class="tocitem" href="#Policy-Based-Planners"><span>Policy-Based Planners</span></a></li><li><a class="tocitem" href="#External-Planners"><span>External Planners</span></a></li></ul></li><li><a class="tocitem" href="../heuristics/">Heuristics</a></li><li><a class="tocitem" href="../specifications/">Specifications</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../simulators/">Simulators</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Planners</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Planners</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/master/docs/src/planners.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Planners"><a class="docs-heading-anchor" href="#Planners">Planners</a><a id="Planners-1"></a><a class="docs-heading-anchor-permalink" href="#Planners" title="Permalink"></a></h1><p>The core of SymbolicPlanners.jl is a library of planning algorithms, or  <a href="#SymbolicPlanners.Planner"><code>Planner</code></a>s:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.Planner" href="#SymbolicPlanners.Planner"><code>SymbolicPlanners.Planner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Planner</code></pre><p>Abstract planner type. Once constructed, a <code>planner</code> can be run on a <code>domain</code>, initial <code>state</code>, and a <code>spec</code>, returning a <a href="../solutions/#SymbolicPlanners.Solution"><code>Solution</code></a>. A <code>problem</code> can be provided instead of a <code>state</code> and <code>spec</code>:</p><pre><code class="nohighlight hljs">planner(domain::Domain, state::State, spec)
planner(domain::Domain, problem::Problem)</code></pre><p>New planners should define <a href="#SymbolicPlanners.solve"><code>solve</code></a> and (optionally) <a href="#SymbolicPlanners.refine!"><code>refine!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/planners.jl#L4-L15">source</a></section></article><p><a href="#SymbolicPlanners.Planner"><code>Planner</code></a>s define the following interface:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.solve" href="#SymbolicPlanners.solve"><code>SymbolicPlanners.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve(planner::Planner, domain::Domain, state::State, spec::Specification)</code></pre><p>Solve a planning problem using the specified <code>planner</code>.</p><p>New subtypes of <a href="#SymbolicPlanners.Planner"><code>Planner</code></a> should implement this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/planners.jl#L23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.refine!" href="#SymbolicPlanners.refine!"><code>SymbolicPlanners.refine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refine!(sol::Solution, planner::Planner, domain::Domain, state::State, spec)</code></pre><p>Refine an existing solution (<code>sol</code>) to a planning problem (in-place). The <code>spec</code> argument can be provided as a <code>Specification</code> or as one or more goal <code>Term</code>s to be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/planners.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.refine" href="#SymbolicPlanners.refine"><code>SymbolicPlanners.refine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refine(sol::Solution, planner::Planner, domain::Domain, state::State, spec)</code></pre><p>Refine a copy of an existing solution to a planning problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/planners.jl#L49-L53">source</a></section></article><h2 id="Breadth-First-Search"><a class="docs-heading-anchor" href="#Breadth-First-Search">Breadth-First Search</a><a id="Breadth-First-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Breadth-First-Search" title="Permalink"></a></h2><p>As a baseline uninformed planning algorithm, one can use  <a href="#SymbolicPlanners.BreadthFirstPlanner"><code>BreadthFirstPlanner</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BreadthFirstPlanner" href="#SymbolicPlanners.BreadthFirstPlanner"><code>SymbolicPlanners.BreadthFirstPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BreadthFirstPlanner(;
    max_nodes::Int = typemax(Int),
    max_time::Float64 = Inf,
    save_search::Bool = false,
    save_search_order::Bool = save_search,
    verbose::Bool = false,
    callback = verbose ? LoggerCallback() : nothing
)</code></pre><p>Breadth-first search planner. Nodes are expanded in order of increasing distance from the initial state (skipping previously visited nodes).</p><p>Returns a <a href="../solutions/#SymbolicPlanners.PathSearchSolution"><code>PathSearchSolution</code></a> or <a href="../solutions/#SymbolicPlanners.NullSolution"><code>NullSolution</code></a>, similar to <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>max_nodes</code>: Maximum number of search nodes before termination.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>save_search</code>: Flag to save the search tree and frontier in the returned solution.</p></li><li><p><code>save_search_order</code>: Flag to save the node expansion order in the returned solution.</p></li><li><p><code>verbose</code>: Flag to print debug information during search.</p></li><li><p><code>callback</code>: Callback function for logging, etc.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/bfs.jl#L3-L22">source</a></section></article><p>Note that [<code>BreadthFirstPlanner</code>] will ignore plan metrics or action costs, returning a plan that has the shortest number of steps, but not necessarily  the lowest cost.</p><h2 id="Forward-Heuristic-Search"><a class="docs-heading-anchor" href="#Forward-Heuristic-Search">Forward Heuristic Search</a><a id="Forward-Heuristic-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Heuristic-Search" title="Permalink"></a></h2><p>The modern day workhorse for automated planning is forward heuristic search, implemented by <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ForwardPlanner" href="#SymbolicPlanners.ForwardPlanner"><code>SymbolicPlanners.ForwardPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardPlanner(;
    heuristic::Heuristic = GoalCountHeuristic(),
    search_noise::Union{Nothing,Float64} = nothing,
    g_mult::Float32 = 1.0f0,
    h_mult::Float32 = 1.0f0,
    max_nodes::Int = typemax(Int),
    max_time::Float64 = Inf,
    fail_fast::Bool = false,
    save_search::Bool = false,
    save_search_order::Bool = save_search,
    verbose::Bool = false,
    callback = verbose ? LoggerCallback() : nothing
)</code></pre><p>Forward best-first search planner, which encompasses uniform-cost search,  greedy search, and A* search. Each node <span>$n$</span> is expanded in order of increasing priority <span>$f(n)$</span>, defined as:</p><p class="math-container">\[f(n) = g_\text{mult} \cdot g(n) + h_\text{mult} \cdot h(n)\]</p><p>where <span>$g(n)$</span> is the path cost from the initial state to <span>$n$</span>, and <span>$h(n)$</span> is the heuristic&#39;s goal distance estimate.</p><p>Returns a <a href="../solutions/#SymbolicPlanners.PathSearchSolution"><code>PathSearchSolution</code></a> if the goal is achieved, containing a  plan that reaches the goal node, and <code>status</code> set to <code>:success</code>. If the node or time budget runs out, the solution will instead contain a partial plan to the last node selected for expansion, with <code>status</code> set to <code>:max_nodes</code> or  <code>:max_time</code> accordingly.</p><p>If <code>save_search</code> is true, the returned solution will contain the search tree and frontier so far. If <code>save_search</code> is true and the search space is exhausted return a <code>NullSolution</code> with <code>status</code> set to <code>:failure</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>heuristic</code>: Search heuristic that estimates cost of a state to the goal.</p></li><li><p><code>search_noise</code>: Amount of Boltzmann search noise (<code>nothing</code> for deterministic search).</p></li><li><p><code>g_mult</code>: Path cost multiplier when computing the <span>$f$</span> value of a search node.</p></li><li><p><code>h_mult</code>: Heuristic multiplier when computing the <span>$f$</span> value of a search node.</p></li><li><p><code>max_nodes</code>: Maximum number of search nodes before termination.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>fail_fast</code>: Flag to terminate search if the heuristic estimates an infinite cost.</p></li><li><p><code>save_search</code>: Flag to save the search tree and frontier in the returned solution.</p></li><li><p><code>save_search_order</code>: Flag to save the node expansion order in the returned solution.</p></li><li><p><code>verbose</code>: Flag to print debug information during search.</p></li><li><p><code>callback</code>: Callback function for logging, etc.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/forward.jl#L5-L44">source</a></section></article><p>Several convenience constructors for variants of <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a> are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.UniformCostPlanner" href="#SymbolicPlanners.UniformCostPlanner"><code>SymbolicPlanners.UniformCostPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">UniformCostPlanner(; kwargs...)
</code></pre><p>Uniform-cost search. Nodes with the lowest path cost from the initial state are expanded first (i.e. the search heuristic is not used).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/forward.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.GreedyPlanner" href="#SymbolicPlanners.GreedyPlanner"><code>SymbolicPlanners.GreedyPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">GreedyPlanner(heuristic; kwargs...)
</code></pre><p>Greedy best-first search, with cycle checking. Nodes with the lowest heuristic value are expanded first (i.e. the cost of reaching them from the initial state is ignored).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/forward.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.AStarPlanner" href="#SymbolicPlanners.AStarPlanner"><code>SymbolicPlanners.AStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AStarPlanner(heuristic; kwargs...)
</code></pre><p>A* search. Nodes with the lowest <span>$f$</span> value are expanded first. This is  guaranteed to produce a cost-optimal solution if the <code>heuristic</code> is admissible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/forward.jl#L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.WeightedAStarPlanner" href="#SymbolicPlanners.WeightedAStarPlanner"><code>SymbolicPlanners.WeightedAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">WeightedAStarPlanner(heuristic, h_mult; kwargs...)
</code></pre><p>Weighted A* search, which multiplies the heuristic estimate by <code>h_mult</code> when computing the <span>$f$</span> value of a node. Nodes with the lowest <span>$f$</span> value are expanded first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/forward.jl#L112">source</a></section></article><p>Probabilistic variants of forward search are also provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ProbForwardPlanner" href="#SymbolicPlanners.ProbForwardPlanner"><code>SymbolicPlanners.ProbForwardPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProbForwardPlanner(;
    search_noise::Float64 = 1.0,
    kwargs...
)</code></pre><p>A probabilistic variant of forward best-first search. Instead of always expanding the node with lowest <span>$f$</span> value in the search frontier, this samples a node to expand according to Boltzmann distribution, where the <span>$f$</span> value of a frontier node is treated as the unnormalized log probability of expansion.</p><p>The temperature for Boltzmann sampling is defined by <code>search_noise</code>. Higher values lead to more random search, lower values lead to more deterministic  search.</p><p>Useful for simulating a diversity of potentially sub-optimal plans, especially when paired with a limited <code>max_nodes</code> budget.    </p><p>An alias for <code>ForwardPlanner{Float64}</code>. See <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a> for other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/forward.jl#L122-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ProbAStarPlanner" href="#SymbolicPlanners.ProbAStarPlanner"><code>SymbolicPlanners.ProbAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ProbAStarPlanner(heuristic; search_noise, kwargs...)
</code></pre><p>A probabilistic variant of A* search. See <a href="#SymbolicPlanners.ProbForwardPlanner"><code>ProbForwardPlanner</code></a> for  how nodes are probabilistically expanded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/forward.jl#L148">source</a></section></article><h2 id="Backward-Heuristic-Search"><a class="docs-heading-anchor" href="#Backward-Heuristic-Search">Backward Heuristic Search</a><a id="Backward-Heuristic-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Heuristic-Search" title="Permalink"></a></h2><p>Due to the flexibility of the PDDL.jl API, SymbolicPlanners.jl supports backward search:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BackwardPlanner" href="#SymbolicPlanners.BackwardPlanner"><code>SymbolicPlanners.BackwardPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackwardPlanner(;
    heuristic::Heuristic = GoalCountHeuristic(:backward),
    search_noise::Union{Nothing,Float64} = nothing,
    g_mult::Float32 = 1.0f0,
    h_mult::Float32 = 1.0f0,
    max_nodes::Int = typemax(Int),
    max_time::Float64 = Inf,
    fail_fast::Bool = false,
    save_search::Bool = false,
    save_search_order::Bool = save_search,
    verbose::Bool = false,
    callback = verbose ? LoggerCallback() : nothing
)</code></pre><p>Heuristic-guided backward (i.e. regression) search planner. Instead of searching forwards, searches backwards from the goal, which is treated as a <em>set</em> of  states which satisfy the goal predicates (equivalently, a <em>partial</em> state,  because only some predicates and fluents may be specified). Each expanded node also corresponds to a partial state. [1]</p><p>As with <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>, each node <span>$n$</span> is expanded in order of increasing priority <span>$f(n)$</span>, defined as:</p><p class="math-container">\[f(n) = g_\text{mult} \cdot g(n) + h_\text{mult} \cdot h(n)\]</p><p>However <span>$g(n)$</span> is instead defined as the path cost from the goal to the current node <span>$n$</span>, and <span>$h(n)$</span> is a heuristic estimate of the distance from the initial state. As such, only certain heuristics, such as <a href="../heuristics/#SymbolicPlanners.GoalCountHeuristic"><code>GoalCountHeuristic</code></a> and  <a href="../heuristics/#SymbolicPlanners.HSPRHeuristic"><code>HSPRHeuristic</code></a> can be used with backward search.</p><p>Returns a <a href="../solutions/#SymbolicPlanners.PathSearchSolution"><code>PathSearchSolution</code></a> or <a href="../solutions/#SymbolicPlanners.NullSolution"><code>NullSolution</code></a>, similar to <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>.</p><p>This planner does not currently support domains with non-Boolean fluents.</p><p>[1] B. Bonet and H. Geffner, &quot;Planning as Heuristic Search,&quot; Artificial Intelligence, vol. 129, no. 1, pp. 5–33, Jun. 2001, <a href="https://doi.org/10.1016/S0004-3702(01)00108-4">https://doi.org/10.1016/S0004-3702(01)00108-4</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>heuristic</code>: Search heuristic that estimates cost of a state to the goal.</p></li><li><p><code>search_noise</code>: Amount of Boltzmann search noise (<code>nothing</code> for deterministic search).</p></li><li><p><code>g_mult</code>: Path cost multiplier when computing the <span>$f$</span> value of a search node.</p></li><li><p><code>h_mult</code>: Heuristic multiplier when computing the <span>$f$</span> value of a search node.</p></li><li><p><code>max_nodes</code>: Maximum number of search nodes before termination.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>fail_fast</code>: Flag to terminate search if the heuristic estimates an infinite cost.</p></li><li><p><code>save_search</code>: Flag to save the search tree and frontier in the returned solution.</p></li><li><p><code>save_search_order</code>: Flag to save the node expansion order in the returned solution.</p></li><li><p><code>verbose</code>: Flag to print debug information during search.</p></li><li><p><code>callback</code>: Callback function for logging, etc.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/backward.jl#L4-L50">source</a></section></article><p>The following convenience constructors are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BackwardGreedyPlanner" href="#SymbolicPlanners.BackwardGreedyPlanner"><code>SymbolicPlanners.BackwardGreedyPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BackwardGreedyPlanner(heuristic; kwargs...)
</code></pre><p>Backward greedy search, with cycle checking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/backward.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BackwardAStarPlanner" href="#SymbolicPlanners.BackwardAStarPlanner"><code>SymbolicPlanners.BackwardAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BackwardAStarPlanner(heuristic; kwargs...)
</code></pre><p>Backward A* search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/backward.jl#L90">source</a></section></article><p>As with <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a>, probabilistic variants of backward search are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ProbBackwardPlanner" href="#SymbolicPlanners.ProbBackwardPlanner"><code>SymbolicPlanners.ProbBackwardPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProbBackwardPlanner(;
    search_noise::Float64 = 1.0,
    kwargs...
)</code></pre><p>A probabilistic variant of backward search, with the same node expansion rule as <a href="#SymbolicPlanners.ProbForwardPlanner"><code>ProbForwardPlanner</code></a>.</p><p>An alias for <code>BackwardPlanner{Float64}</code>. See <a href="#SymbolicPlanners.BackwardPlanner"><code>BackwardPlanner</code></a> for other arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/backward.jl#L98-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ProbBackwardAStarPlanner" href="#SymbolicPlanners.ProbBackwardAStarPlanner"><code>SymbolicPlanners.ProbBackwardAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ProbBackwardAStarPlanner(heuristic; search_noise, kwargs...)
</code></pre><p>A probabilistic variant of backward A* search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/backward.jl#L115">source</a></section></article><h2 id="Bidirectional-Search"><a class="docs-heading-anchor" href="#Bidirectional-Search">Bidirectional Search</a><a id="Bidirectional-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Bidirectional-Search" title="Permalink"></a></h2><p>A simple implementation of bidirectional search is provided by  <a href="#SymbolicPlanners.BidirectionalPlanner"><code>BidirectionalPlanner</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BidirectionalPlanner" href="#SymbolicPlanners.BidirectionalPlanner"><code>SymbolicPlanners.BidirectionalPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">planner = BidirectionalPlanner(;
    forward::ForwardPlanner = ForwardPlanner(),
    backward::BackwardPlanner = BackwardPlanner(),
    max_nodes::Int = typemax(Int),
    max_time::Float64 = Inf,
    save_search::Bool = false
)</code></pre><p>A bi-directional planner which simulataneously runs a forward search from the initial state and backward search from the goal, succeeding if either search is successful, or if the search frontiers are detected to cross.</p><p>Frontier crossing is detected by checking whether the most recently expanded forward node is subsumed by a node in the backward search frontier, or vice versa. Subsumption means that the partial state represented by a backward node is consistent with the complete state represented by forward node.</p><p>While the above procedure is not complete (i.e. some crossings will be missed), it represents a trade-off between the cost of testing for subsumption and the  benefit of detecting a crossing, in lieu of more sophisticated methods [1].</p><p>[1] V. Alcázar, S. Fernández, and D. Borrajo, &quot;Analyzing the Impact of Partial States on Duplicate Detection and Collision of Frontiers,&quot; ICAPS (2014), <a href="https://doi.org/10.1609/icaps.v24i1.13677">https://doi.org/10.1609/icaps.v24i1.13677</a></p><p><strong>Arguments</strong></p><ul><li><p><code>forward</code>: Forward search configuration.</p></li><li><p><code>backward</code>: Forward search configuration.</p></li><li><p><code>max_nodes</code>: Maximum number of search nodes before termination.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>save_search</code>: Flag to save the search tree and frontier in the returned solution.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/bidirectional.jl#L3-L32">source</a></section></article><p>The following convenience constructors are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BiGreedyPlanner" href="#SymbolicPlanners.BiGreedyPlanner"><code>SymbolicPlanners.BiGreedyPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiGreedyPlanner(f_heuristic, b_heuristic; kwargs...)
</code></pre><p>Bidirectional greedy best-first search, where <code>f_heuristic</code> is the forward search heuristic and <code>b_heuristic</code><code>is the backward search heuristic. Options specified as</code>kwargs` are shared by both the backward and forward search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/bidirectional.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.BiAStarPlanner" href="#SymbolicPlanners.BiAStarPlanner"><code>SymbolicPlanners.BiAStarPlanner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiAStarPlanner(f_heuristic, b_heuristic; kwargs...)
</code></pre><p>Bidirectional A* search, where <code>f_heuristic</code> is the forward search heuristic and <code>b_heuristic</code><code>is the backward search heuristic. Options specified as</code>kwargs` are shared by both the backward and forward search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/bidirectional.jl#L84">source</a></section></article><h2 id="Policy-Based-Planners"><a class="docs-heading-anchor" href="#Policy-Based-Planners">Policy-Based Planners</a><a id="Policy-Based-Planners-1"></a><a class="docs-heading-anchor-permalink" href="#Policy-Based-Planners" title="Permalink"></a></h2><p>Unlike most systems for automated symbolic planning, SymbolicPlanners.jl includes several policy-based planners which return <a href="../solutions/#SymbolicPlanners.PolicySolution"><code>PolicySolution</code></a>s.</p><p>These planners are especially useful for stochastic environments (even if the planner operates over a determinized version of the true domain), since they compute what action should be performed in each encountered state, rather than just a sequence of ordered actions. They are also useful for real-time planning via reuse of previous solutions.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.RealTimeDynamicPlanner" href="#SymbolicPlanners.RealTimeDynamicPlanner"><code>SymbolicPlanners.RealTimeDynamicPlanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RealTimeDynamicPlanner(;
    heuristic::Heuristic = GoalCountHeuristic(),
    n_rollouts::Int = 50,
    max_depth::Int = 50,
    rollout_noise::Float64 = 0.0,
    action_noise::Float64 = 0.0,
    verbose::Bool = false,
    callback = verbose ? LoggerCallback() : nothing
)</code></pre><p>Planner that uses Real Time Dynamic Programming (<code>RTDP</code> for short), a form of asynchronous value iteration which performs greedy rollouts from the initial state, updating the value estimates of states encountered along the way [1].</p><p>If a <code>heuristic</code> is provided, the negated heuristic value will be used as an initial value estimate for newly encountered states (since the value of a state in a shortest path problem is the cost to reach the goal), thereby guiding early rollouts.</p><p>For admissible (i.e. optimistic) heuristics, convergence to the true value function is guaranteed in the reachable state space after a sufficient number of rollouts.</p><p>Returns a <a href="../solutions/#SymbolicPlanners.TabularPolicy"><code>TabularPolicy</code></a> (wrapped in a <a href="../solutions/#SymbolicPlanners.BoltzmannPolicy"><code>BoltzmannPolicy</code></a> if <code>action_noise &gt; 0</code>), which stores the value estimates and action Q-values for each encountered state. </p><p>[1] A. G. Barto, S. J. Bradtke, and S. P. Singh, &quot;Learning to Act using Real-Time Dynamic Programming,&quot; Artificial Intelligence, vol. 72, no. 1, pp. 81–138, Jan. 1995, <a href="https://doi.org/10.1016/0004-3702(94)00011-O">https://doi.org/10.1016/0004-3702(94)00011-O</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>heuristic</code>: Search heuristic used to initialize the value function.</p></li><li><p><code>n_rollouts</code>: Number of rollouts to perform from the initial state.</p></li><li><p><code>max_depth</code>: Maximum depth of each rollout.</p></li><li><p><code>rollout_noise</code>: Amount of Boltzmann noise during simulated rollouts.</p></li><li><p><code>action_noise</code>: Amount of Boltzmann action noise for the returned policy.</p></li><li><p><code>verbose</code>: Flag to print debug information during search.</p></li><li><p><code>callback</code>: Callback function for logging, etc.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/rtdp.jl#L3-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.RealTimeHeuristicSearch" href="#SymbolicPlanners.RealTimeHeuristicSearch"><code>SymbolicPlanners.RealTimeHeuristicSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RealTimeHeuristicSearch(;
    heuristic::Heuristic = GoalCountHeuristic(),
    n_iters::Int = 10,
    max_nodes::Int = 50,
    kwargs...
)

RealTimeHeuristicSearch(
    planner::ForwardPlanner,
    n_iters::Int
)</code></pre><p>A real time heuristic search algorithm (<code>RTHS</code> for short) [1]. Similar to <code>RTDP</code>, except that instead of greedy rollouts, lookahead heuristic search is performed from each neighbor of the current state (up to a budget of <code>max_nodes</code>). States encountered during search are used to update the neighbors&#39; value estimates, then a simulated step is taken from the current state to the highest-value neighbor. This is repeated for <code>n_iters</code>,  with future searches using the updated value estimates as more informed heuristics. Any <code>kwargs</code> are passed to the <a href="#SymbolicPlanners.ForwardPlanner"><code>ForwardPlanner</code></a> used internally for search.</p><p>Each time heuristic search is performed, state values are updated by backpropagating the value estimate of the terminal search node <span>$t$</span> (i.e., the node about to be expanded when forward search terminates due to reaching the goal or a resource limit) to all non-frontier nodes <span>$s$</span> in the search tree:</p><p class="math-container">\[V(s) = -[f(t) - g(s)] = -[g(t) + h(t) - g(s)] = -[(g(t) - g(s)) + h(t)]\]</p><p>where <span>$g(t)$</span> is the path cost from the root of the search tree to <span>$t$</span>, <span>$h(t)$</span> is the heuristic goal-distance estimate for <span>$t$</span>, and <span>$f(t) = g(t) + h(t)$</span>, the priority value for the terminal node.</p><p>Intuitively, the updated value of <span>$V(s)$</span> is the (negative) estimated cost from <span>$s$</span> to the goal, computed by summing the distance from <span>$s$</span> to <span>$t$</span> with the estimated distance of <span>$t$</span> to the goal. This update rule follows a variant of Learning Real Time A* (LRTA) [1] called Real-Time Adaptive A* (RTAA) [2]. Note that the RTAA* update rule requires initial heuristic values to be consistent in order for the updated heuristic values to remain admissible (and consistent).</p><p>Returns a <a href="../solutions/#SymbolicPlanners.TabularVPolicy"><code>TabularVPolicy</code></a>, which stores the value estimates for each encountered state. Although this planner returns a policy, it expects a deterministic domain as input.</p><p>[1] R. E. Korf, &quot;Real-Time Heuristic Search,&quot; Artificial Intelligence, vol. 42, no. 2, pp. 189–211, Mar. 1990, <a href="https://doi.org/10.1016/0004-3702(90)90054-4">https://doi.org/10.1016/0004-3702(90)90054-4</a>.</p><p>[2] S. Koenig and M. Likhachev, “Real-Time Adaptive A*,” AAMAS (2006), pp. 281–288. <a href="https://doi.org/10.1145/1160633.1160682">https://doi.org/10.1145/1160633.1160682</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/rths.jl#L3-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.MonteCarloTreeSearch" href="#SymbolicPlanners.MonteCarloTreeSearch"><code>SymbolicPlanners.MonteCarloTreeSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonteCarloTreeSearch(
	n_rollouts::Int64 = 50,
	max_depth::Int64 = 50,
	heuristic::Heuristic = NullHeuristic(),
	selector::MCTSNodeSelector = BoltzmannUCBSelector(),
	estimator::MCTSLeafEstimator = RandomRolloutEstimator()
end</code></pre><p>Planner that uses Monte Carlo Tree Search (<code>MCTS</code> for short) [1], with a  customizable initial value <code>heuristic</code>, node <code>selector</code> strategy, and leaf node value <code>estimator</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>n_rollouts</code>: Number of search rollouts to perform.</p></li><li><p><code>max_depth</code>: Maximum depth of rollout (including the selection and estimation phases).</p></li><li><p><code>heuristic</code>: Initial value heuristic for newly encountered states / leaf nodes.</p></li><li><p><code>selector</code>: Node selection strategy for previously visited nodes (e.g. MaxUCB).</p></li><li><p><code>estimator</code>: Estimator for leaf node values (e.g. random or policy-based rollouts).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/mcts.jl#L139-L155">source</a></section></article><h2 id="External-Planners"><a class="docs-heading-anchor" href="#External-Planners">External Planners</a><a id="External-Planners-1"></a><a class="docs-heading-anchor-permalink" href="#External-Planners" title="Permalink"></a></h2><p>Wrappers for several external planners are provided:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.FastDownward" href="#SymbolicPlanners.FastDownward"><code>SymbolicPlanners.FastDownward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastDownward(
    search::String = &quot;astar&quot;,
    heuristic::String = &quot;add&quot;,
    h_params::Dict{String, String} = Dict(),
    max_time::Float64 = 300,
    verbose::Bool = false,
    log_stats::Bool = true,
    fd_path::String = get(ENV, &quot;FD_PATH&quot;, &quot;&quot;),
    py_cmd::String = get(ENV, &quot;PYTHON&quot;, &quot;python&quot;)
)</code></pre><p>Wrapper for the FastDownward planning system [1]. The planner has to be installed locally for this wrapper to be used. Consult the FastDownward documentation for further explanation of options.</p><p>[1] M. Helmert, &quot;The Fast Downward Planning System,&quot; Journal of Artificial Intelligence Research, vol. 26, pp. 191–246, Jul. 2006, <a href="https://doi.org/10.1613/jair.1705">https://doi.org/10.1613/jair.1705</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>search</code>: String specifying search algorithm (e.g. &quot;astar&quot;, &quot;ehc&quot;).</p></li><li><p><code>heuristic</code>: String specifying search heuristic (e.g. &quot;add&quot;, &quot;lmcut&quot;,).</p></li><li><p><code>h_params</code>: Heuristic parameters as a dictionary mapping names to values.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>verbose</code>: Flag to print planner outputs.</p></li><li><p><code>log_stats</code>: Flag to log solution statistics.</p></li><li><p><code>fd_path</code>: Path to <code>fast_downward.py</code>.</p></li><li><p><code>py_cmd</code>: Path to Python executable.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/external.jl#L50-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.Pyperplan" href="#SymbolicPlanners.Pyperplan"><code>SymbolicPlanners.Pyperplan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pyperplan(
    search::String = &quot;astar&quot;,
    heuristic::String = &quot;add&quot;,
    log_level::String = &quot;info&quot;,
    log_stats::Bool = true,
    max_time::Float64 = 300,
    verbose::Bool = false,
    py_cmd::String = get(ENV, &quot;PYTHON&quot;, &quot;python&quot;)
)</code></pre><p>Wrapper for the Pyperplan lightweight STRIPS planner [1]. The planner has to be installed locally for this wrapper to be used. Consult the Pyperplan documentation for further explanation of options.</p><p>[1] Y. Alkhazraji et al., &quot;Pyperplan.&quot; Zenodo, 2020. <a href="https://doi.org/10.5281/zenodo.3700819">https://doi.org/10.5281/zenodo.3700819</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>search</code>: String specifying search algorithm (e.g. &quot;astar&quot;, &quot;gbf&quot;).</p></li><li><p><code>heuristic</code>: String specifying search heuristic (e.g. &quot;hadd&quot;, &quot;hmax&quot;,).</p></li><li><p><code>log_level</code>: How much information to log when running the planner.</p></li><li><p><code>log_stats</code>: Flag to log solution statistics.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>verbose</code>: Flag to print planner outputs.</p></li><li><p><code>py_cmd</code>: Path to Python executable.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/external.jl#L158-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicPlanners.ENHSP" href="#SymbolicPlanners.ENHSP"><code>SymbolicPlanners.ENHSP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ENHSP(
    search::String = &quot;astar&quot;,
    heuristic::String = &quot;add&quot;,
    h_mult::Float64 = 1.0,
    log_stats::Bool = true,
    max_time::Float64 = 300,
    verbose::Bool = false,
    enhsp_path::String = get(ENV, &quot;ENHSP_PATH&quot;, &quot;&quot;),
    java_cmd::String = get(ENV, &quot;JAVA&quot;, &quot;java&quot;)
)</code></pre><p>Wrapper for the Expressive Numeric Heuristic Search Planner (ENHSP) [1]. The planner has to be installed locally for this wrapper to be used. Consult the ENHSP documentation for further explanation of options.</p><p>[1] E. Scala et al., &quot;ENHSP&quot;, <a href="https://sites.google.com/view/enhsp/">https://sites.google.com/view/enhsp/</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>search</code>: String specifying search algorithm (e.g. &quot;gbfs&quot;, &quot;WAStar&quot;).</p></li><li><p><code>heuristic</code>: String specifying search heuristic (e.g. &quot;hadd&quot;, &quot;aibr&quot;,).</p></li><li><p><code>h_mult</code>: Heuristic multiplier for weighted A*.</p></li><li><p><code>log_stats</code>: Flag to log solution statistics.</p></li><li><p><code>max_time</code>: Maximum time in seconds before planner times out.</p></li><li><p><code>verbose</code>: Flag to print planner outputs.</p></li><li><p><code>enhsp_path</code>: Path to <code>enhsp.jar</code>.</p></li><li><p><code>java_cmd</code>: Path to Java executable.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlanners/SymbolicPlanners.jl/blob/6d2214d2efdab92e280a7c9b697a9bd3534acf0d/src/planners/external.jl#L257-L278">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../heuristics/">Heuristics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Friday 22 December 2023 23:36">Friday 22 December 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
